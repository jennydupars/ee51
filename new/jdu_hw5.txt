	NAME	KEYPAD
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;	                                 KEYPAD                                  ;
;                                   Homework 5                               ;
;                                   EE/CS 51                                 ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; This file contains the functions for keypad input reading. The functions included are:
;   InitKeypad - initializes variables used to scan and debounce keypad. 
; KeypadMux - keypad scanning and debouncing function
; Revision History:
;     10/31/16  	Jennifer Du      initial revision
; KeypadScanner 
;
; Description:  This function is the keypad scanning and debouncing function for 
;	            the RoboTrike. This function is called by the timer event handler, 
;	            and every time it is called, it either checks for a new key being 
;	            pressed if none is currently pressed, or debounces the currently 
;	            pressed key. Once it has a debounced key, this function will call 
;	            the supplied EnqueueEvent function with the key event in AH and the 
;	            key value in AL. The EnqueueEvent stores the events and key values 
;	            passed to it in a 256 byte buffer called EventBuf. 
;
;	            This function will be able to handle at most 2 keys pressed at the
;	            same time. 
;
; Operation:    This function keeps track of what keys have been pressed and for how 
;	            long in two shared variables. First, it reads from the 
;	            input location, and from the value given, we will be able to tell which
;	            keys have been pressed. From this, we store the key values in the 
;               variables key1val and key2val, and the duration of their pressed 
;               status in key1status and key2status. 
;
; Arguments:    None. 
; Return Value:	None. 
;
; Local Variables:	
; Shared Variables:  key1 - tells us which key is being pressed
;                    key1Count - tells us how long this key has been pressed 
;                    key2 - tells us which key is also being pressed
;                    key2Count - tells us how long this key has been pressed 
; Global Variables: None. 
;
; Input: User input to the keypad. 
; Output: None.
;
; Error Handling: None. 
; Registers Used:
;
; Algorithms: None. 
; Data Structures:  
;	          
                                        
Pseudocode: 
    
read the input: 
first go through the input and see if we need to send in input to enqueueEvent 
    if key1 or key2 are now unpressed, look at their counts 
        calculate key's location: based on location (080H to 083H, and the 
                value from the number (e = 1st, d = 2nd, b = 3rd, 7 = 4th) 
        (if Count above 30, then sendEventToEnqueueEvent)
            return the keyCount = 0 and set key = unpressed_val
        (if Count not above 30, then that's a glitch, so ignore it)        
            return the keyCount = 0 and set key = unpressed_val
    if key1 or key2 are still pressed, increment counter. 

check if key1 or key2 are still occupied 
    both still occupied ->
        if key1Count has reached 100, sendEventToEnqueueEvent
        if key2Count has reached 100, sendEventToEnqueueEvent
        can't take anymore input, so return 
    at least one is unoccupied, you can take one more input, so:
        scan through the input again and see which new keys are pressed 
            store in key1 or key2, whichever is unused.
            increment its count to 1 

sendEventToEnqueueEvent 
    AL: first digit is row, second digit is column (loc 080H, val e = 0e) 
    AH: 01 means pressed, 00 means unpressed 
    EnqueueEvent(AX)
            
;	
;
; InitKeypad  
;
; Description:  This function initializes the variables used in keeping track of what 
;               keys are being pressed on the keypad. 
;
; Operation:    Set vars key1 and key2 to the unpressed value, set vars key1count 
;               and key2count to 0.
;
; Arguments:        None. 
; Return Value:     None.
; Local Variables:  None. 
; Shared Variables: key1 - holds value of the first key being pressed 
;                   key2 - holds value of the second key being pressed 
;                   key1count - holds the amount of time the key has been pressed  
;                   key2count - holds the amount of time key 2 has been pressed 
; Global Variables:	None. 
; Input:            None. 
; Output:           None.
; Error Handling:   None.
; Registers used:   None. 
; Algorithms:       None.
; Data Structures:  None. 

Pseudocode: 

    key1 = unpressed_val
    key2 = unpressed_val
    key1Count = 0
    key2Count = 0

;
; the data segment 
DATA	SEGMENT	PUBLIC 'DATA'
    key1            ; holds value of the first key being pressed 
    key2            ; holds value of the second key being pressed 
    key1Count       ; holds the amount of time the key has been pressed  
    key2Count       ; holds the amount of time key 2 has been pressed 
DATA	ENDS
