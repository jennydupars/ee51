8086/87/88/186 MACRO ASSEMBLER    CONVERTS                                                 19:20:20  10/29/;6  PAGE    1


DOS 5.0 (038-N) 8086/87/88/186 MACRO ASSEMBLER V3.1 ASSEMBLY OF MODULE CONVERTS
OBJECT MODULE PLACED IN CONVERTS.OBJ
ASSEMBLER INVOKED BY:  C:\UTIL\ASM86.EXE CONVERTS.ASM M1 DB EP


LOC  OBJ                  LINE     SOURCE

                             1        NAME     CONVERTS
                             2     
                             3     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             4     ;                                                                            ;
                             5     ;                                   CONVERTS                                 ;
                             6     ;                             Conversion Functions                           ;
                             7     ;                                   EE/CS 51                                 ;
                             8     ;                                                                            ;
                             9     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            10     
                            11     
                            12     ; This file holds the two convert functions: Dec2String, and Hex2String. 
                            13     ;
                            14     ; Revision History:
                            15     ;     10/10/16    Jennifer Du     initial revision
                            16     ;     10/13/16    Jennifer Du     writing assembly code 
                            17     ;     10/16/16    Jennifer Du     touching up comments
                            18     
                            19 +1  $INCLUDE(converts.inc)
                      =1    20     
                      =1    21     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      =1    22     ;                                                                            ;
                      =1    23     ;                                  CONVERTS.INC                              ;
                      =1    24     ;                               Conversion Functions                         ;
                      =1    25     ;                                  Include File                              ;
                      =1    26     ;                                                                            ;
                      =1    27     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      =1    28     
                      =1    29     ;This file contains the non-magic numbers for convert.
                      =1    30     
                      =1    31     ; constants used in both:
                      =1    32     
  0041                =1    33     ASCIIa          EQU             65          ; ascii value for 'A' 
  0030                =1    34     ASCII0          EQU             48          ; ascii value for '0' 
  002D                =1    35     ASCIIdash       EQU     45          ; ascii value for '-'
  0000                =1    36     NULL        EQU     0                   ; ascii value for null character
                      =1    37     
                      =1    38     ; no magic numbers for BX counter
  0005                =1    39     bFIVE       EQU     0005H
  0004                =1    40     bFOUR       EQU     0004H
  0003                =1    41     bTHREE      EQU     0003H
  0002                =1    42     bTWO        EQU     0002H
  0001                =1    43     bONE        EQU     0001H
  0000                =1    44     ZERO        EQU     0000H
                      =1    45     
                      =1    46     
                      =1    47     
                      =1    48     ; constants used in Dec2String:
                      =1    49     
  2710                =1    50     TENto4      EQU     2710H               ; powers of 10: 10000
8086/87/88/186 MACRO ASSEMBLER    CONVERTS                                                 19:20:20  10/29/;6  PAGE    2


LOC  OBJ                  LINE     SOURCE

  03E8                =1    51     TENto3      EQU     03E8H               ; powers of 10: 1000
  0064                =1    52     TENto2      EQU     0064H               ; powers of 10: 100
  000A                =1    53     TENto1      EQU     000AH               ; powers of 10: 10
                      =1    54     
  8000                =1    55     TEST1STBIT    EQU     8000H     ; test first bit for 1 or 0
                      =1    56     
                      =1    57     
                      =1    58     
                      =1    59     ; constants used in Hex2String:
                      =1    60     
  0004                =1    61     FOURBITS        EQU             4                       ; used for shifting 4 bits le
                                   ft or right
                      =1    62     
  F000                =1    63     FIRST4BITS  EQU     0F000H      ; gets first 4 digits of numbers compared to it
  000A                =1    64     TEN         EQU     000AH       ; for use when comparing numbers to 10
                            65     
                            66     CGROUP   GROUP    CODE
                            67     
----                        68     CODE     SEGMENT  PUBLIC 'CODE'
                            69     
                            70              ASSUME   CS:CGROUP
                            71     
                            72     ; Dec2String
                            73     ;
                            74     ; Description:       This function converts the 16-bit number n to a string 
                            75     ;                    containing its decimal representation stored at a. The 
                            76     ;                    function is passed a 16-bit signed value (n) to convert 
                            77     ;                    to decimal, and store as a string. The string will 
                            78     ;                    contain the <null> terminated decimal representation of 
                            79     ;                    the value in ASCII. The resulting string is stored 
                            80     ;                    starting at the memory location indicated by the passed 
                            81     ;                    address (a). The number (n) is passed in AX by value. The 
                            82     ;                    address (a) is passed in SI by value.
                            83     ;
                            84     ; Operation:         Divide by successive powers of 10(decimal) to get decimal 
                            85     ;                    representation. Negative numbers are detected and turned 
                            86     ;                    into their two's complement first.
                            87     ;
                            88     ; Arguments:         AX - binary value to convert to decimal.
                            89     ;                    SI - address location to store result.
                            90     ;
                            91     ; Return Value:      SI - address location to store result.
                            92     ;
                            93     ; Local Variables:   AX - binary value to convert to decimal.
                            94     ;                    SI - string location.
                            95     ;                    BX - pointer to determine highest power of 10 < AX
                            96     ;                    CX - powers of ten that AX is divided by
                            97     ;                    DX - remainder after dividing AX by powers of 10.
                            98     ;
                            99     ; Shared Variables:  None.
                           100     ; Global Variables:  None.
                           101     ;
                           102     ; Input:             None.
                           103     ; Output:            None.
                           104     ;
8086/87/88/186 MACRO ASSEMBLER    CONVERTS                                                 19:20:20  10/29/;6  PAGE    3


LOC  OBJ                  LINE     SOURCE

                           105     ; Error Handling:    None.
                           106     ;
                           107     ; Algorithms:        Repeatedly divide by powers of 10 and repeat for 
                           108     ;                    remainders. Then turn quotients into digits and 
                           109     ;                    add necessary negative signs.
                           110     ;
                           111     ; Data Structures:   None.
                           112     ;
                           113     ; Known Bugs:        None.
                           114     ;
                           115     ; Registers Changed: AX, BX, SI, CX, DX
                           116     ; Stack Depth:       0
                           117     ;
                           118     
                           119     
0000                       120     Dec2String     PROC     NEAR
                           121                    PUBLIC   Dec2String
                           122     
0000                       123     dec2stringinit:
0000 BB0500                124        MOV BX,bFIVE         ; set counter to 5 (will divide input 5 times)
0003 BA0000                125        MOV DX,ZERO             ; make DX 0 initially
                           126        
0006                       127     signOfNumber:
0006 8BD0                  128        MOV DX,AX            ; save AX before you find sign
0008 250080                129        AND AX,TEST1STBIT         ; get first bit
000B 3D0080                130        CMP AX,TEST1STBIT         ; test if first bit =1 or =0
000E 744C                  131        JZ ifNegative        ; if =1, number is negative
0010 8BC2                  132        MOV AX,DX            ; move input value back into AX
                           133     
0012                       134     convertPart:
0012 BA0000                135        MOV DX,ZERO             ; clear DX again so DIV can work
                           136                             
0015 83FB04                137        CMP BX,bFOUR         ; if 2nd iteration (BX=4),
0018 7417                  138        JZ divide10to3          ; divide AX by 1000
001A 83FB03                139        CMP BX,bTHREE        ; if 3rd iteration (BX=3), 
001D 741A                  140        JZ divide10to2          ; divide by 100
001F 83FB02                141        CMP BX,bTWO          ; if 4th iteration (BX=2),   
0022 741D                  142        JZ divide10to1          ; divide by 10
0024 83FB01                143        CMP BX,bONE          ; if 5th iteration (BX=1),
0027 7420                  144        JZ divide10to0          ; divide by 1
                           145     
0029                       146     divide10to4:
0029 B91027                147        MOV CX,TENto4        ; get ready to divide AX by 10000
002C F7F1                  148        DIV CX               ; divide AX by 10000 
002E EB1C90                149        JMP addDigit         ; then add digit to string
                           150     
0031                       151     divide10to3:
0031 B9E803                152        MOV CX,TENto3        ; get ready to divide by 1000
0034 F7F1                  153        DIV CX               ; divide number by 1000 
0036 EB1490                154        JMP addDigit         ; then add digit to string
                           155     
0039                       156     divide10to2:
0039 B96400                157        MOV CX,TENto2        ; get ready to divide by 1000
003C F7F1                  158        DIV CX               ; divide number by 100 
003E EB0C90                159        JMP addDigit         ; then add digit to string
8086/87/88/186 MACRO ASSEMBLER    CONVERTS                                                 19:20:20  10/29/;6  PAGE    4


LOC  OBJ                  LINE     SOURCE

                           160     
0041                       161     divide10to1:
0041 B90A00                162        MOV CX,TENto1        ; get ready to divide by 10
0044 F7F1                  163        DIV CX               ; divide number by 10 
0046 EB0490                164        JMP addDigit         ; then add digit to string
                           165     
0049                       166     divide10to0:
0049 EB0190                167        JMP addDigit         ; (divide by 1) then add digit to string
                           168     
004C                       169     addDigit:
004C 053000                170        ADD AX,ASCII0        ; add '0' to get ascii value of quotient AX
004F 8804                  171        MOV BYTE PTR[SI],AL  ; add ascii(AX) to string
0051 46                    172        INC SI               ; increment SI pointer by a word's space
0052 8BC2                  173        MOV AX,DX            ; move remainder from previous division into AX
0054 4B                    174        DEC BX               ; decrement BX (counter)
0055 83FB00                175        CMP BX,ZERO          ; are we at the end? (eval BX == 0)
0058 740C                  176        JZ dec2StringAddNull ; if (BX==0) then we add null char
005A EBB6                  177        JMP convertPart      ; otherwise convert next digit
                           178     
005C                       179     ifNegative:
005C 8BC2                  180        MOV AX,DX            ; move value back into AX
005E C6042D                181        MOV BYTE PTR[SI],ASCIIdash  ;move the char into string place
0061 46                    182        INC SI               ; increment pointer by a byte's space
0062 F7D8                  183        NEG AX               ; negate binary of AX
0064 EBAC                  184        JMP convertPart      ; then just convert it
                           185     
0066                       186     dec2StringAddNull:
0066 C60400                187        MOV BYTE PTR[SI],NULL ;end the string with <null>
0069 C3                    188        RET
                           189     Dec2String     ENDP
                           190     
                           191     
                           192     
                           193     
                           194     ; Hex2String
                           195     ;
                           196     ; Description:       This function converts the 16-bit number n to a string 
                           197     ;                    containing its hexadecimal representation stored at a. 
                           198     ;                    The function is passed a 16-bit unsigned value (n) to 
                           199     ;                    convert to hexadecimal and store as a string. The string 
                           200     ;                    will contain the <null> terminated hexadecimal 
                           201     ;                    representation of the value in ASCII. The resulting 
                           202     ;                    string is stored starting at the memory location 
                           203     ;                    indicated by the passed address (a). The number (n) is 
                           204     ;                    passed in AX by value. The address (a) is passed in SI by 
                           205     ;                    value.
                           206     ;
                           207     ; Operation:         The function selects the first, then the second, etc 
                           208     ;                    groups of 4 digits using the AND operation. Then the 
                           209     ;                    corresponding ASCII character is found and added to the
                           210     ;                    string.
                           211     ;
                           212     ; Arguments:         AX - binary value to convert to hexadecimal.
                           213     ;                    SI - address to store result at.
                           214     ; Return Value:      SI - address to store result at.
8086/87/88/186 MACRO ASSEMBLER    CONVERTS                                                 19:20:20  10/29/;6  PAGE    5


LOC  OBJ                  LINE     SOURCE

                           215     ;
                           216     ; Local Variables:   AX - binary value to convert to hexadecimal.
                           217     ;                    SI - address to store result at.
                           218     ;                    BX - counter to repeat process 4 times.
                           219     ;                    CX - temporary storage for AX's bits, removing 4 at a time
                           220     ;
                           221     ; Shared Variables:  None.
                           222     ; Global Variables:  None.
                           223     ;
                           224     ; Input:             None.
                           225     ; Output:            None.
                           226     ;
                           227     ; Error Handling:    None.
                           228     ;
                           229     ; Algorithms:        Divide the number into 4 4-bit parts and match them with 
                           230     ;                    corresponding ASCII value.
                           231     ; Data Structures:   None.
                           232     ;
                           233     ; Registers Changed: AX, BX, SI, CX
                           234     ; Stack Depth:       0
                           235     ;
                           236     
                           237     
006A                       238     Hex2String     PROC     NEAR
                           239                    PUBLIC   Hex2String
                           240     
006A                       241     hex2StringInit:
006A BB0000                242        MOV BX,0             ; set counter to 0
006D 8BC8                  243        MOV CX,AX            ; save AX
                           244     
006F                       245     startOver:
006F 2500F0                246        AND AX,FIRST4BITS    ; get first 4 digits, which goes to AX
0072 C1E804                247        SHR AX,FOURBITS      ; shift AX right 12 bits to get true value of the bits
0075 C1E804                248        SHR AX,FOURBITS
0078 C1E804                249        SHR AX,FOURBITS
007B 3D0A00                250        CMP AX,TEN           ; compare digits to ten
007E 7D15                  251        JGE greaterThanTen   ; if >= 10, jump to more than 10
                           252     
0080                       253     lessThanTen:            ; if four bits is less than 10
0080 053000                254        ADD AX,ASCII0        ; add the value to ascii value for 0
0083 8804                  255        MOV BYTE PTR[SI],AL  ; move the char into string place
0085 46                    256        INC SI               ; increment pointer 
0086 8BC1                  257        MOV AX,CX            ; move number back into AX
0088 C1E004                258        SHL AX,FOURBITS      ; shift bits left to remove first 4
008B 8BC8                  259        MOV CX,AX            ; move lower bits to CX
008D 43                    260        INC BX               ; add one to the counter
008E 83FB04                261        CMP BX,bFOUR         ; stop when you've done it 4 times
0091 741A                  262        JZ hex2StringAddNull     ; If BX=4 you end.
0093 EBDA                  263        JMP startOver        ; do this process again if BX != 4
                           264     
0095                       265     greaterThanTen:         ; if we need an ABCDEF (greater than 10)
0095 2D0A00                266        SUB AX,TEN           ; AX = AX - 10
0098 054100                267        ADD AX,ASCIIa        ; AX + ASCIIa
009B 8804                  268        MOV BYTE PTR[SI],AL  ; move AX's character into string
009D 46                    269        INC SI               ; increment pointer 
8086/87/88/186 MACRO ASSEMBLER    CONVERTS                                                 19:20:20  10/29/;6  PAGE    6


LOC  OBJ                  LINE     SOURCE

009E 8BC1                  270        MOV AX,CX            ; move number back into AX
00A0 C1E004                271        SHL AX,FOURBITS      ; shift bits left to remove first 4
00A3 8BC8                  272        MOV CX,AX            ; save AX in CX
00A5 43                    273        INC BX               ; increment BX
00A6 83FB04                274        CMP BX,bFOUR         ; have we done this 4 times?
00A9 7402                  275        JZ hex2StringAddNull     ; if BX=4 you end.
00AB EBC2                  276        JMP startOver        ; do this process again if BX != 4
                           277     
00AD                       278     hex2StringAddNull:
00AD C60400                279        MOV BYTE PTR[SI],NULL ;end the string with <null>
00B0 C3                    280        RET
                           281     Hex2String     ENDP
                           282     
----                       283     CODE     ENDS
                           284     
                           285     END

ASSEMBLY COMPLETE, NO ERRORS FOUND
