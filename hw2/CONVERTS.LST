8086/87/88/186 MACRO ASSEMBLER    CONVERTS                                                 14:49:36  10/16/;6  PAGE    1


DOS 5.0 (038-N) 8086/87/88/186 MACRO ASSEMBLER V3.1 ASSEMBLY OF MODULE CONVERTS
OBJECT MODULE PLACED IN CONVERTS.OBJ
ASSEMBLER INVOKED BY:  C:\UTIL\ASM86.EXE CONVERTS.ASM M1 DB EP


LOC  OBJ                  LINE     SOURCE

                             1        NAME     CONVERTS
                             2     
                             3     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             4     ;                                                                            ;
                             5     ;                                   CONVERTS                                 ;
                             6     ;                             Conversion Functions                           ;
                             7     ;                                   EE/CS 51                                 ;
                             8     ;                                                                            ;
                             9     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            10     
                            11     
                            12     ; This file holds the two convert functions: Dec2String, and Hex2String. 
                            13     ;
                            14     ; Revision History:
                            15     ;     10/10/16    Jennifer Du     initial revision
                            16     ;     10/13/16    Jennifer Du     writing assembly code 
                            17     
                            18 +1  $INCLUDE(converts.inc)
                      =1    19     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      =1    20     ;                                                                            ;
                      =1    21     ;                                  CONVERTS.INC                              ;
                      =1    22     ;                               Conversion Functions                         ;
                      =1    23     ;                                  Include File                              ;
                      =1    24     ;                                                                            ;
                      =1    25     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      =1    26     
                      =1    27     ;This file contains the non-magic numbers for convert.
                      =1    28     
  0041                =1    29     ASCIIa          EQU             65          ; ascii value for 'A' 
  0030                =1    30     ASCII0          EQU             48          ; ascii value for '0' 
  002D                =1    31     ASCIIdash       EQU     45          ; ascii value for '-'
  0000                =1    32     NULL        EQU     0
  0005                =1    33     FIVE        EQU     0005H
  0004                =1    34     FOURBITS        EQU             4
                      =1    35     
  2710                =1    36     TENto4      EQU     2710H
  03E8                =1    37     TENto3      EQU     03E8H
  0064                =1    38     TENto2      EQU     0064H
  000A                =1    39     TENto1      EQU     000AH
                      =1    40     
                            41     
                            42     CGROUP   GROUP    CODE
                            43     
----                        44     CODE     SEGMENT  PUBLIC 'CODE'
                            45     
                            46              ASSUME   CS:CGROUP
                            47     
                            48     ; Dec2String
                            49     ;
                            50     ; Description:       This function converts the 16-bit number n to a string 
8086/87/88/186 MACRO ASSEMBLER    CONVERTS                                                 14:49:36  10/16/;6  PAGE    2


LOC  OBJ                  LINE     SOURCE

                            51     ;                    containing its decimal representation stored at a. The 
                            52     ;                    function is passed a 16-bit signed value (n) to convert 
                            53     ;                    to decimal, and store as a string. The string will 
                            54     ;                    contain the <null> terminated decimal representation of 
                            55     ;                    the value in ASCII. The resulting string is stored 
                            56     ;                    starting at the memory location indicated by the passed 
                            57     ;                    address (a). The number (n) is passed in AX by value. The 
                            58     ;                    address (a) is passed in SI by value.
                            59     ;
                            60     ; Operation:         Divide by successive powers of 10(decimal) to get decimal 
                            61     ;                    representation. Negative numbers are detected and turned 
                            62     ;                    into their two's complement first.
                            63     ;
                            64     ; Arguments:         AX - binary value to convert to decimal.
                            65     ;                    SI - address location to store result.
                            66     ;
                            67     ; Return Value:      SI - address location to store result.
                            68     ;
                            69     ; Local Variables:   AX - binary value to convert to decimal.
                            70     ;                    SI - string location.
                            71     ;                    BX - pointer to determine highest power of 10 < AX
                            72     ;                    DX - remainder after dividing AX by powers of 10.
                            73     ;
                            74     ; Shared Variables:  None.
                            75     ; Global Variables:  None.
                            76     ;
                            77     ; Input:             None.
                            78     ; Output:            None.
                            79     ;
                            80     ; Error Handling:    None.
                            81     ;
                            82     ; Algorithms:        Repeatedly divide by powers of 10 and repeat for 
                            83     ;                    remainders. Then turn quotients into digits and 
                            84     ;                    add necessary negative signs.
                            85     ;
                            86     ; Data Structures:   None.
                            87     ;
                            88     ; Known Bugs:        None.
                            89     ;
                            90     
                            91     
0000                        92     Dec2String     PROC     NEAR
                            93                    PUBLIC   Dec2String
                            94     
0000                        95     dec2stringinit:
0000 BB0500                 96        MOV BX,5             ;set counter to 4 (aka divide by 10 4,3,2,1,0 times)
0003 BA0000                 97        MOV DX,0             ; make DX 0 initially
                            98        
0006                        99     signOfNumber:
0006 8BD0                  100        MOV DX,AX            ; save AX before you find sign
0008 250080                101        AND AX,8000H         ;get first bit
000B 3D0080                102        CMP AX,8000H         ; if the first bit is 1
000E 744C                  103        JZ ifNegative
0010 8BC2                  104        MOV AX,DX            ; move value back into AX
                           105     
8086/87/88/186 MACRO ASSEMBLER    CONVERTS                                                 14:49:36  10/16/;6  PAGE    3


LOC  OBJ                  LINE     SOURCE

0012                       106     convertPart:
0012 BA0000                107        MOV DX,0             ; clear DX again so DIV can work
0015 83FB04                108        CMP BX,0004H
0018 7417                  109        JZ divide10to3
001A 83FB03                110        CMP BX,0003H
001D 741A                  111        JZ divide10to2
001F 83FB02                112        CMP BX,0002H
0022 741D                  113        JZ divide10to1
0024 83FB01                114        CMP BX,0001H
0027 7420                  115        JZ divide10to0
                           116     
0029                       117     divide10to4:
0029 B91027                118        MOV CX,TENto4
002C F7F1                  119        DIV CX        ;divide number by 10000 (quotient:AX, remainder:DX)
002E EB1C90                120        JMP addDigit
                           121     
0031                       122     divide10to3:
0031 B9E803                123        MOV CX,TENto3
0034 F7F1                  124        DIV CX        ;divide number by 1000 (quotient:AX, remainder:DX)
0036 EB1490                125        JMP addDigit
                           126     
0039                       127     divide10to2:
0039 B96400                128        MOV CX,TENto2
003C F7F1                  129        DIV CX        ;divide number by 100 (quotient:AX, remainder:DX)
003E EB0C90                130        JMP addDigit
                           131     
0041                       132     divide10to1:
0041 B90A00                133        MOV CX,TENto1
0044 F7F1                  134        DIV CX        ;divide number by 10 (quotient:AX, remainder:DX)
0046 EB0490                135        JMP addDigit
                           136     
0049                       137     divide10to0:
0049 EB0190                138        JMP addDigit
                           139     
004C                       140     addDigit:
004C 053000                141        ADD AX,ASCII0        ;add to get ascii value of quotient
004F 8804                  142        MOV BYTE PTR[SI],AL  ;add ascii of the number to string
0051 46                    143        INC SI               ;increment pointer by a word's space
0052 8BC2                  144        MOV AX,DX            ;move remainder into AX
0054 4B                    145        DEC BX               ;decrement BX
0055 83FB00                146        CMP BX,0             ; are we at the end?
0058 740C                  147        JZ dec2StringAddNull
005A EBB6                  148        JMP convertPart      ;do it again for the next digit
                           149     
005C                       150     ifNegative:
005C 8BC2                  151        MOV AX,DX            ; move value back into AX
005E C6042D                152        MOV BYTE PTR[SI],ASCIIdash  ;move the char into string place
0061 46                    153        INC SI          ;increment pointer by a byte's space
0062 F7D8                  154        NEG AX               ;negate it: ax = -ax
0064 EBAC                  155        JMP convertPart      ;then just convert it
                           156     
0066                       157     dec2StringAddNull:
0066 C60400                158        MOV BYTE PTR[SI],NULL ;end the string with <null>
0069 C3                    159        RET
                           160     Dec2String     ENDP
8086/87/88/186 MACRO ASSEMBLER    CONVERTS                                                 14:49:36  10/16/;6  PAGE    4


LOC  OBJ                  LINE     SOURCE

                           161     
                           162     
                           163     
                           164     
                           165     ; Hex2String
                           166     ;
                           167     ; Description:       This function converts the 16-bit number n to a string 
                           168     ;                    containing its hexadecimal representation stored at a. 
                           169     ;                    The function is passed a 16-bit unsigned value (n) to 
                           170     ;                    convert to hexadecimal and store as a string. The string 
                           171     ;                    will contain the <null> terminated hexadecimal 
                           172     ;                    representation of the value in ASCII. The resulting 
                           173     ;                    string is stored starting at the memory location 
                           174     ;                    indicated by the passed address (a). The number (n) is ;        
                                               passed in AX by value. The address (a) is passed in SI by 
                           175     ;                    value.
                           176     ;
                           177     ; Operation:         The function selects the first, then the second, etc 
                           178     ;                    groups of 4 digits using the AND operation. Then the 
                           179     ;                    corresponding ASCII character is found and added to the
                           180     ;                    string.
                           181     ;
                           182     ; Arguments:         AX - binary value to convert to hexadecimal.
                           183     ;                    SI - address to store result at.
                           184     ; Return Value:      SI - address to store result at.
                           185     ;
                           186     ; Local Variables:   AX - binary value to convert to hexadecimal.
                           187     ;                    SI - address to store result at.
                           188     ;                    BX - counter to repeat process 4 times.
                           189     ;
                           190     ; Shared Variables:  None.
                           191     ; Global Variables:  None.
                           192     ;
                           193     ; Input:             None.
                           194     ; Output:            None.
                           195     ;
                           196     ; Error Handling:    None.
                           197     ;
                           198     ; Algorithms:        Divide the number into 4 4-bit parts and match them with 
                           199     ;                    corresponding ASCII value.
                           200     ; Data Structures:   None.
                           201     ;
                           202     ; Registers Changed: AX, BX, SI
                           203     ; Stack Depth:       0
                           204     ;
                           205     
                           206     
006A                       207     Hex2String     PROC     NEAR
                           208                    PUBLIC   Hex2String
                           209     
006A                       210     hex2StringInit:
006A BB0000                211        MOV BX,0             ;set counter to 0
006D 8BC8                  212        MOV CX,AX
                           213     
006F                       214     startOver:
8086/87/88/186 MACRO ASSEMBLER    CONVERTS                                                 14:49:36  10/16/;6  PAGE    5


LOC  OBJ                  LINE     SOURCE

006F 2500F0                215        AND AX,0F000H        ;get first 4 digits, which goes to AX
0072 C1E804                216        SHR AX,FOURBITS
0075 C1E804                217        SHR AX,FOURBITS
0078 C1E804                218        SHR AX,FOURBITS
007B 3D0A00                219        CMP AX,000AH         ; compare digits to 10d
007E 7D15                  220        JGE greaterThanTen    ;if >= 10, jump to more than 10
                           221     
0080                       222     lessThanTen:
0080 053000                223        ADD AX,ASCII0        ;add the value to ascii value for 0
0083 8804                  224        MOV BYTE PTR[SI],AL  ;move the char into string place
0085 46                    225        INC SI        ;increment pointer by a word's space
0086 8BC1                  226        MOV AX,CX
0088 C1E004                227        SHL AX,FOURBITS      ; shift bits left 
008B 8BC8                  228        MOV CX,AX
008D 43                    229        INC BX               ; add one to the count
008E 83FB04                230        CMP BX,4             ; stop when you've done it 4 times
0091 741A                  231        JZ hex2StringAddNull           ; If BX=4 you end.
0093 EBDA                  232        JMP startOver        ; do this process again if BX != 4
                           233     
0095                       234     greaterThanTen:         ;if we need an ABCDEF
0095 2D0A00                235        SUB AX,000AH         ;ax = ax - 10
0098 054100                236        ADD AX,ASCIIa        ;AX + ASCIIa
009B 8804                  237        MOV BYTE PTR[SI],AL  ;move AX's character into the string place
009D 46                    238        INC SI        ;increment pointer by a word's space
009E 8BC1                  239        MOV AX,CX
00A0 C1E004                240        SHL AX,FOURBITS      ; shift bits left 
00A3 8BC8                  241        MOV CX,AX
00A5 43                    242        INC BX               ; increment BX
00A6 83FB04                243        CMP BX,4             
00A9 7402                  244        JZ hex2StringAddNull           ; if BX=4 you end.
00AB EBC2                  245        JMP startOver        ; do this process again if BX != 4
                           246     
00AD                       247     hex2StringAddNull:
00AD C60400                248        MOV BYTE PTR[SI],NULL ;end the string with <null>
00B0 C3                    249        RET
                           250     Hex2String     ENDP
                           251     
----                       252     CODE     ENDS
                           253     
                           254     END

ASSEMBLY COMPLETE, NO ERRORS FOUND
